<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Saturday, June 08, 2011, 10:50 PM -->
<!-- MuClient version 4.31 -->

<!-- Plugin "smoothTick" generated by Plugin Wizard -->

<muclient>
<plugin
   name="smoothTick"
   author="Spartacus"
   id="f64e84495f161a3c1b2f640c"
   language="Lua"
   purpose="a better tick timer"
   save_state="y"
   date_written="2011-06-08 10:48:38"
   requires="4.73"
   version="1.0"
   >
</plugin>

<!--  Timers  -->

<timers>
  <timer
   enabled="y"
   at_time="n"
   second="0.100"
   send_to="12"
   >
  <send>
    last_tick = last_tick or os.clock ()
    s = os.clock() - last_tick
    WindowRectOp (win, miniwin.rect_fill, 0, 0, 0, 0, bgColor)
    drawMenuHandle()
    drawFace()
    drawHand(math.min(30,s))
    winTitle()
    if s &lt;= 30 then
      --Note(30-s, ' seconds to tick')
      -- df2()
      local digits = string.format('%02d',round(30-s))
      WindowText(win, 'fDigit', digits, (WindowInfo(win, 3) / 2 - WindowTextWidth(win, 'fDigit', digits, false) / 2) + 1, 0.65 * WindowInfo(win, 4), 0, 0, textColor, false)
      WindowShow(win, true)
    else
      local digits = string.format('%02d',round(30-s))
      local tmpColor
      local l = round(10.0*(30-s))/10.0
      if math.abs(l) &gt;= math.abs(lateThresh) and math.abs(l) &lt; math.abs(discThresh) then
        tmpColor = lateColor
      elseif math.abs(l) &gt;= math.abs(discThresh) then
        tmpColor = discColor
      else
        tmpColor = textColor
      end
      WindowText(win, 'fDigit', digits, (WindowInfo(win, 3) / 2 - WindowTextWidth(win, 'fDigit', digits, false) / 2) + 1, 0.65 * WindowInfo(win, 4), 0, 0, tmpColor, false)
      -- WindowShow(win, true)
      Redraw()
    end
  </send>
  </timer>
</timers>

<script>
<![CDATA[

require "serialize"

local handlers = {}

function df2()
  res = WindowCircleOp(win, 1,  -- window, action
                       cx - 4 - 52, cy + 6 - 52, cx + 5 + 52, cy + 15 + 52, -- left, top, right, bottom
                       markColor, 512, 1, -- penColor, penStyle, penWidth
                       markColor, 1,  -- brushColor, brushStyle
                       0, 0, 0, 0)  -- extras
  res = WindowCircleOp(win, 1, cx - 4, cy + 6, cx + 5, cy + 15, pinColor, 0, 1, 0, 0, 0, 0)
end

function trim(s)
  return (s:gsub("^%s*(.-)%s*$", "%1"))
end

function OnPluginTelnetOption (option)
   if option == string.char (101,1) then
      -- last_tick = os.time()
      last_tick = os.clock()
      -- SetStatus ("Time to tick: " .. (last_tick + 30) - os.time ())
   end -- if
end -- function

function OnPluginInstall ()
  setDefaults()
  loadState()
  -- if disabled last time, stay disabled
  if GetVariable ("enabled") == "false" then
    ColourNote ("yellow", "", "Warning: Plugin " .. GetPluginName ().. " is currently disabled.")
    check (EnablePlugin(GetPluginID (), false))
    return
  else
    showTicker()
  end -- they didn't enable us last time  
end -- OnPluginInstall

-- pull in telnet option handling
local paths = { GetPluginInfo(GetPluginID (), 20) .. "telnet_options.lua",
                GetInfo(60) .. "Aardwolf\\telnet_options.lua",
                GetInfo(60) .. "telnet_options.lua",
                GetInfo(59) .. "telnet_options.lua" }
local tnOpFile
local tnOpFound = false
local i = 1

while not tnOpFound and i < #paths do
  tnOpFile = paths[i]
  tnOpFound = utils.readdir(tnOpFile)
  i = i + 1
end -- while not tnOpFound

if not tnOpFound then
  Note("To use smoothTick, you must have telnet_options.lua installed in one of the following paths:")
  for _, p in pairs(paths) do Note("    ", p) end
  Note()
  Hyperlink("http://www.gammon.com.au/mushclient/plugins/Aardwolf/telnet_options.lua",
            "Click here to download telnet_options.lua",
            "click to download telnet_options.lua",
            "white", "red",
            true)
  Note()
  ColourNote("yellow","black","Disabling smoothTick.")
  ColourNote("yellow","black","To turn smoothTick on after installing telnet_options.lua,")
  ColourNote("yellow","black","press Ctrl-Shift-P, select smoothTick, and click on the 'Enable' button.")
  EnablePlugin(GetPluginID(), false)
end --
dofile (tnOpFile)

function OnPluginDisable ()
  setDefaults()
  OnPluginSaveState()
  WindowDelete(win)
end -- OnPluginSaveState
  
function OnPluginEnable ()
  setDefaults()
  loadState()
  showTicker()
end -- OnPluginEnable

function OnPluginSaveState ()
  if win == nil then setDefaults() end
  if WindowInfo(win, 7) ~= nil then
    SetVariable ("enabled", tostring (GetPluginInfo (GetPluginID (), 17)))
    SetVariable ("lay", WindowInfo(win, 7))
    SetVariable ("flags", WindowInfo(win, 8))
    SetVariable ("posx", WindowInfo(win, 10))
    SetVariable ("posy", WindowInfo(win, 11))
    SetVariable ("zord", WindowInfo(win, 22))
  end
  if bgColor ~= nil then
    SetVariable ("bgColor", bgColor)
    SetVariable ("pinColor", pinColor)
    SetVariable ("faceColor", faceColor)
    SetVariable ("facePattern", facePattern)
    SetVariable ("handColor", handColor)
    SetVariable ("markColor", markColor)
    SetVariable ("menuColor", menuColor)
    SetVariable ("textColor", textColor)
    SetVariable ("titleColor", titleColor)
    SetVariable ("lateThresh", lateThresh)
    SetVariable ("discThresh", discThresh)
    SetVariable ("lateColor", lateColor)
    SetVariable ("discColor", discColor)
    SetVariable ("facetCount", facetCount)
  end
  if titleFont ~= nil then
    SetVariable ("titleFont", serialize.save("titleFont", titleFont))
  end
    if digitFont ~= nil then
    SetVariable ("digitFont", serialize.save("digitFont", digitFont))
  end
  if facetFont ~= nil then
    SetVariable ("facetFont", serialize.save("facetFont", facetFont))
  end
end -- OnPluginSaveState

function loadState ()
  lay = tonumber(GetVariable ("lay")) or 0
  flags = tonumber(GetVariable ("flags")) or 0
  bgColor = tonumber(GetVariable ("bgColor")) or ColourNameToRGB("black")
  pinColor = tonumber(GetVariable ("pinColor")) or ColourNameToRGB("deepskyblue")
  faceColor = tonumber(GetVariable ("faceColor")) or ColourNameToRGB("deepskyblue")
  facePattern = tonumber(GetVariable ("facePattern")) or 1
  handColor = tonumber(GetVariable ("handColor")) or ColourNameToRGB("red")
  markColor = tonumber(GetVariable ("markColor")) or ColourNameToRGB("deepskyblue")
  menuColor = tonumber(GetVariable ("menuColor")) or ColourNameToRGB("gray")
  textColor = tonumber(GetVariable ("textColor")) or ColourNameToRGB("lime")
  titleColor = tonumber(GetVariable ("titleColor")) or ColourNameToRGB("white")
  
  lateThresh = tonumber(GetVariable ("lateThresh")) or 0.3
  discThresh = tonumber(GetVariable ("discThresh")) or 2.0
  lateColor = GetVariable ("lateColor") or ColourNameToRGB("yellow")
  discColor = GetVariable ("discColor") or ColourNameToRGB("orange")
  
  facetCount = GetVariable ("facetCount") or 12
  
  posx = tonumber(GetVariable ("posx")) or 100
  posy = tonumber(GetVariable ("posy")) or 100
  zord = tonumber(GetVariable ("zord")) or 1200
  
  local t = GetVariable("titleFont")
  local d = GetVariable("digitFont")
  local f = GetVariable("facetFont")
  -- this should set our font variables
  r = t ~= nil and loadstring(t)()
  r = d ~= nil and loadstring(d)()
  r = f ~= nil and loadstring(f)()
  
  --Note("Placing window '", win, "' at (", posx, ", ", posy, ")")
  --WindowPosition(win, posx, posy, 0, setbit(flags, 2))
  WindowSetZOrder(win, zord)
end --loadState

function setDefaults()
  cx = 60 -- center X
  cy = 50 -- center Y

  pid = GetPluginID() or '000NotAPlugin000'
  win = pid .. '_' .. 'ticker'
end -- setDefaults

function loadFont(id, f, ds)
  --Trebuchet MS
  local nm, sz, bl, it, ul, so
  if f ~= nil then
    nm, sz, bl, it, ul, so = f.name, f.size, f.bold, f.italic, f.underline, f.strikeout
  else
    nm, sz, bl, it, ul, so = '-NoFont', ds, false, false, false, false
  end
  WindowFont (win, id, nm, sz, bl, it, ul, so) -- define font
end -- loadFont

function showTicker()
  posx = tonumber(GetVariable('posx')) or 250
  posy = tonumber(GetVariable('posy')) or 250
  flags = tonumber(GetVariable('flags')) or 6

  x = WindowCreate(win, posx, posy, 121, 121, 12, setbit(flags, 2), bgColor)
  WindowSetZOrder(win, 1200)
  WindowShow(win, true)
  
  loadFont('fTitle', titleFont, 8)
  loadFont('fDigit', digitFont, 14)
  loadFont('fFacet', facetFont, 8)
  
  winTitle()
  drawFace()
   
  -- set up the drag handler
  tWinEvents = handlers.new(win)
  WindowAddHotspot(win, "hs1",  
                   0, 0, 120, 120,   -- rectangle
                   "",   -- MouseOver
                   "",   -- CancelMouseOver
                   "tWinEvents.mousedown",
                   "tWinEvents.cancelmousedown", 
                   "tWinEvents.mouseup", 
                   "Left-Click to drag this window.\nRight-Click to configure smoothTick.",  -- tooltip text
                   1, 0)  -- hand cursor

  myMenu = setupMenu()
  WindowAddHotspot(win, "0hs",  
                   0, 0, 20, 20,   -- rectangle
                   "",   -- MouseOver
                   "",   -- CancelMouseOver
                   "",
                   "", 
                   "myMenu.showMenu", 
                   "Click to configure smoothTick.",  -- tooltip text
                   1, 0)  -- hand cursor
  WindowDragHandler (win, "hs1", "tWinEvents.dragmove", "tWinEvents.dragrelease", 0)
end --showTicker

function bringToFront(ow)
  local wl = WindowList()
  local m
  for _, w in pairs(wl) do
      m = math.max(m or 0, WindowInfo(w, 22))
  end
  Note(#wl, ' windows.  max Z = ', m)
  WindowSetZOrder(ow, m + 1)
end --bringToFront

function sendToBack(ow)
  local wl = WindowList()
  local m
  for _, w in pairs(wl) do
      m = math.min(m or 0, WindowInfo(w, 22))
  end
  Note(#wl, ' windows.  min Z = ', m)
  WindowSetZOrder(ow, m - 1)
end --sendToBack
-------------------------------------------------------------------------------
-- BEGIN miniwindow menu class
-------------------------------------------------------------------------------
local menu = {}
function menu.new(win)
  local self = {}
  self.win = win
  
  function self.add(item)
    -- a menu item table should contain the following elements:
    --   displayName = text to be displayed on the menu.
    --   enabled     = boolean true to enable, false to disable
    --   checked     = function to determine whether or not the item is checked.
    --                 true = checked, false = unchecked.  If a boolean value is
    --                 supplied, then the state can not be changed by the menu.
    --   callback    = function to call when the menu item is selected
    --   submenu     = boolean true if future items should be children of this
    --                 item.  true with nil display name to end a submenu.
    -- if item is nil, then a separator will be added
    -- if displayName is nil and submenu is true the current submenu will end
    local msg = ''
    self.menu = self.menu or {}
    self.mActive = {}
    menu = self.menu -- shortcut
    
    if item == nil then
      table.insert(menu, {displayName = '-'})
      return
    end
    if item.displayName == nil and item.submenu then
      table.insert(menu, {displayName = '<'})
      return
    end
    
    if type(item.displayName) ~= 'string' and type(item.displayName) ~= 'function' then
      msg = 'menu item ' .. #menu + 1 .. ' could not be added.  displayName must be string or a function that returns string.'
    end
    if type(item.enabled) ~= 'boolean' and type(item.enabled) ~= 'function' then
      msg = msg .. '\n' .. 'menu item ' .. item.displayName .. ' could not be added.  enabled must be boolean or a function that returns boolean.'
    end
    if not item.submenu and type(item.callback) ~= 'function' then
      msg = msg .. '\n' .. 'menu item ' .. item.displayName .. ' could not be added.  callback must be a function.'
    end
    
    if msg:len() > 0 then
      -- something is wrong with this menu item, so we are not going to use it.
      ColourNote("yellow","black",msg)
      ColourNote("yellow","black","please notify the plugin author of this problem.")
    else
      -- add new item
      n = n or 1
      table.insert(menu, {displayName = item.displayName, enabled = item.enabled, checked = item.checked, callback = item.callback, submenu = item.submenu})
    end
    return
  end --self.add
  
  function self.buildMenu()
    local mStr = ''
    for _, item in pairs(self.menu) do
      if mStr:len() > 0 then mStr = mStr .. ' | ' else mStr = '!' end
      if item.displayName == '-' or item.displayName == '<' then
        mStr = mStr .. item.displayName  
      else
        if type(item.checked)=='function' then checked = item.checked() else checked = item.checked end
        if type(item.enabled)=='function' then enabled = item.enabled() else enabled = item.enabled end
        if type(item.submenu)=='function' then submenu = item.submenu() else submenu = item.submenu end
        if checked ~= nil then
          if checked then
            mStr = mStr .. '+' .. item.displayName
          else
            mStr = mStr .. item.displayName
          end
          -- this item counts, so tag it and increment our counter
          table.insert(self.mActive, item)
        elseif enabled == false then -- we don't want nil values to give us a false negative on this flag...
          mStr = mStr .. '^' .. item.displayName  -- not counted
        elseif submenu then
          mStr = mStr .. '>' .. item.displayName
          -- this item counts, so tag it and increment our counter
          -- table.insert(self.mActive, item)
        else
          mStr = mStr .. item.displayName
          -- this item counts, so tag it and increment our counter
          table.insert(self.mActive, item)        
        end
      end
    end
    return mStr
  end --self.buildMenu
  
  function self.showMenu(flags, hotspot_id)  -- this is what will be called to start the menu
    OnPluginSaveState()
    mStr = self.buildMenu()
    --Note('mStr = ', mStr)
    --Note(#self.mActive, ' active items processed.')
    if mStr:len() == 0 then return end
    local res = tonumber(WindowMenu(self.win, 5, 5, mStr)) or -1
    if res > 0 and res <= #self.mActive then
      self.mActive[res].callback()
    elseif res >= 1 then
      ColourNote('yellow','black','Unkown menu option (' .. res .. ').  Please contact the plugin developer.')
    end
    OnPluginSaveState()
  end --self.showMenu
  
  return self
end --menu.new
-------------------------------------------------------------------------------
-- END miniwindow menu class
-------------------------------------------------------------------------------
function setupMenu()
  local cfgMenu = menu.new(win)
      -- a menu item table should contain the following elements:
      --   displayName = text to be displayed on the menu.
      --   enabled     = boolean true to enable, false to disable
      --   checked     = function or variable to determine whether or not the
      --                 item is checked.  true = checked, false = unchecked.
      --                 If a boolean value is supplied, then the state can
      --                 not be changed by the menu.
      --   callback    = function to call when the menu item is selected
      --   submenu     = boolean true if future items should be children of this
      --                 item.  true with nil display name to end a submenu.
      -- if item is nil, then a separator will be added
      -- if displayName is nil and submenu is true the current submenu will end
  cfgMenu.add({displayName = 'Font', enabled = true, submenu = true})
  cfgMenu.add({displayName = 'Title', enabled = true, callback = function ()
                                                                    local n, s, c = fontDetails(titleFont)
                                                                    titleFont = utils.fontpicker(n, s, c)
                                                                    loadFont('fTitle', titleFont, 8)
                                                                 end})
  cfgMenu.add({displayName = 'Face', enabled = true, callback = function ()
                                                                    local n, s, c = fontDetails(facetFont)
                                                                    facetFont = utils.fontpicker(n, s, c)
                                                                    loadFont('fFacet', facetFont, 8)
                                                                 end})
  cfgMenu.add({displayName = 'Digital', enabled = true, callback = function ()
                                                                    local n, s, c = fontDetails(digitFont)
                                                                    digitFont = utils.fontpicker(n, s, c)
                                                                    loadFont('fDigit', digitFont, 8)
                                                                 end})
  cfgMenu.add({displayName = nil, submenu = true}) -- end sub menu
  cfgMenu.add({displayName = 'Transparent', enabled = true,
               checked = function() return (bgColor == WindowInfo(win, 9) and hasbit(WindowInfo(win, 8), 4)) end,
               callback = function ()
                            local flags = WindowInfo(win, 8)
                            if hasbit(flags, 4) then bgColor = WindowInfo(win, 9) end
                            WindowPosition(win, posx, posy, 0, flipbit(flags, 2))
                          end})
  cfgMenu.add({displayName = 'Colors', enabled = true, submenu = true})
  cfgMenu.add({displayName = 'Background', enabled = true, callback = function() bgColor=getColor(bgColor) end})
  cfgMenu.add({displayName = 'Center Pin', enabled = true, callback = function() pinColor=getColor(pinColor) end})
  cfgMenu.add({displayName = 'Face', enabled = true, callback = function() faceColor=getColor(faceColor) end})
  cfgMenu.add({displayName = 'Hand', enabled = true, callback = function() handColor=getColor(handColor) end})
  cfgMenu.add({displayName = 'Marks', enabled = true, callback = function() markColor=getColor(markColor) end})
  cfgMenu.add({displayName = 'Menu Handle', enabled = true, callback = function() menuColor=getColor(menuColor) end})
  cfgMenu.add({displayName = 'Digital', enabled = true, callback = function() digitColor=getColor(digitColor) end})
  cfgMenu.add({displayName = 'Title', enabled = true, callback = function() titleColor=getColor(titleColor) end})
  cfgMenu.add({displayName = 'Late', enabled = true, callback = function() lateColor=getColor(lateColor) end})
  cfgMenu.add({displayName = 'Disconnected', enabled = true, callback = function() discColor=getColor(discColor) end})
  cfgMenu.add({displayName = nil, submenu = true}) -- end sub menu
  cfgMenu.add({displayName = 'Face Pattern', enabled = true, submenu = true})
  cfgMenu.add({displayName = 'solid', enabled = true, checked = function () return (facePattern == 0) end, callback = function () facePattern = 0 end})
  cfgMenu.add({displayName = 'none', enabled = true, checked = function () return (facePattern == 1) end, callback = function () facePattern = 1 end})
  cfgMenu.add({displayName = 'horizontal hatch', enabled = true, checked = function () return (facePattern == 2) end, callback = function () facePattern = 2 end})
  cfgMenu.add({displayName = 'vertical hatch', enabled = true, checked = function () return (facePattern == 3) end, callback = function () facePattern = 3 end})
  cfgMenu.add({displayName = 'forward diagonal', enabled = true, checked = function () return (facePattern == 4) end, callback = function () facePattern = 4 end})
  cfgMenu.add({displayName = 'backward diagonal', enabled = true, checked = function () return (facePattern == 5) end, callback = function () facePattern = 5 end})
  cfgMenu.add({displayName = 'cross hatch', enabled = true, checked = function () return (facePattern == 6) end, callback = function () facePattern = 6 end})
  cfgMenu.add({displayName = 'diagonal cross hatch', enabled = true, checked = function () return (facePattern == 7) end, callback = function () facePattern = 7 end})
  cfgMenu.add({displayName = 'fine fill', enabled = true, checked = function () return (facePattern == 8) end, callback = function () facePattern = 8 end})
  cfgMenu.add({displayName = 'medium fill', enabled = true, checked = function () return (facePattern == 9) end, callback = function () facePattern = 9 end})
  cfgMenu.add({displayName = 'coarse fill', enabled = true, checked = function () return (facePattern == 10) end, callback = function () facePattern = 10 end})
  cfgMenu.add({displayName = 'horizontal waves', enabled = true, checked = function () return (facePattern == 11) end, callback = function () facePattern = 11 end})
  cfgMenu.add({displayName = 'vertical waves', enabled = true, checked = function () return (facePattern == 12) end, callback = function () facePattern = 12 end})
  cfgMenu.add({displayName = nil, submenu = true}) -- end sub menu
  cfgMenu.add(nil) -- separator
  cfgMenu.add({displayName = 'Late Threshold', enabled = true, callback = function()
                                                                            local msg = "How long should a tick be overdue before considered late?  (seconds)"
                                                                            local title = "late tick threshold"
                                                                            lateThresh = getNumber(msg, title, lateThresh) or lateThresh
                                                                          end})
  cfgMenu.add({displayName = 'Disc Threshold', enabled = true, callback = function()
                                                                            local msg = "How long should a tick be overdue before considered disconnected?  (seconds)"
                                                                            local title = "disconnect threshold"
                                                                            discThresh = getNumber(msg, title, discThresh) or discThresh
                                                                          end})
  cfgMenu.add({displayName = '# of Facets', enabled = true, callback = function()
                                                                         local msg = "Please enter number of facets to draw on the clock face."
                                                                         local title = "facet count"
                                                                         facetCount = getNumber(msg, title, facetCount) or facetCount
                                                                       end })
  cfgMenu.add(nil) -- separator
  cfgMenu.add({displayName = 'Bring to Front', enabled = true, callback = function () bringToFront(win) end})
  cfgMenu.add({displayName = 'Send to Back', enabled = true, callback = function () sendToBack(win) end})
  cfgMenu.add(nil) -- separator
  cfgMenu.add({displayName = 'Help', enabled = true, callback = function ()
                                                                  Note('OpenBrowser returned: ',
                                                                    OpenBrowser('http://code.google.com/p/aardspart/wiki/smoothTick'))
                                                                end})
  return cfgMenu
end

function fontDetails(f)
  if f ~= nil then
    return f.name, f.size, f.color
  else
    return '-NoFont-', 8, 0
  end
end --fontDetails

function getNumber(msg, title, def)
  return utils.inputbox(msg, title, def, nil, nil, { validate = function (n)
                                                                        if tonumber(n) ~= nil then
                                                                          return true
                                                                        else
                                                                          return false
                                                                        end
                                                                      end
                                                          })
end --getNumber

function getFont(f)
  local n = utils.fontpicker(f.name, f.colour, f.size)
  if n == nil then
    return f
  else
    return n
  end
end --getFont

function getColor(c)
  local newColor = PickColour (c)
  if newcolor ~= -1 then
    c = newColor
  end
  return c
end --getColor

function round(v)
    local r = 0
    if type(v) == 'number' then
        i, f = math.modf(v)
        if f > 0.5 then
            r = i + 1
        else
            r = i
        end
    end
    return r
end --round

function drawFace()
    local r = 54
    local dpd = 360 / facetCount -- degrees per mark on the clock face
    local cx = WindowInfo(win, 3)/2 + 1
    local cy = WindowInfo(win, 4)/2 + 1
    
    markSize = 2
    d = 360
    fmt = '(sin, cos)=(%1.3f, %1.3f)  (x, y)=(%d, %d)'
    local size
    while d >= dpd do
        local s = math.sin(2 * math.pi * (360 - d) / 360)
        local c = math.cos(2 * math.pi * (360 - d) / 360)
        
        --if d == 0 then 
        --elseif d == 180 then
        --elseif d % 90 == 0 then
        --elseif d % 30 == 0 then
        --end
        x1 = round(cx - r * s)
        y1 = round(cy - r * c)
        x2 = round(cx + (r + markSize) * s)
        y2 = round(cy + (r + markSize) * c)
        --WindowLine(win, x1, y1, x2, y2, markColor, 0, 2)
        WindowCircleOp(win, 1, x1-markSize, y1-markSize, x1+markSize, y1+markSize, markColor, 0, 1, 0, 0, 0, 0)
        -- if you're gonna use text for the marks, you havta offset based on
        -- the font.  I don't wanna do this right now...
        -- res = WindowText(win, 'fFacet', '.', x1, y1, 0, 0, markColor, false)
        d = d - dpd
    end
    r2 = 8
    -- big circle
    res = WindowCircleOp(win, 1, cx - (r-4), cy - (r-4), cx + (r-4), cy + (r-4), bgColor, 5, 0, faceColor, facePattern, 0, 0, 0, 0)
    -- little circle
    res = WindowCircleOp(win, 1, cx - r2, cy - r2, cx + r2, cy + r2, pinColor, 0, 1, faceColor, 1, 0, 0, 0, 0)
    -- drawX()
end --drawFace

function drawX()
  WindowLine(win, 2, 2, 119, 119, handColor, 256, 1)
  WindowLine(win, 2, 119, 119, 2, handColor, 256, 1)
end --drawX

function drawHand(t)
    local spt = 30.0  -- seconds per tick - divisions in the circle
    local sups = 10.0 -- sub-units per second
    local r = 50 -- radius of the hand
    
    a = 2 * math.pi * (spt - t) / spt  -- angle of the line
    local s = math.sin(a)
    local c = math.cos(a)
    
    -- for a needle that extends past center
    -- x1 = 1+round(cx + 0.1 * r * s)
    -- y1 = 10 + round(cy + 0.1 * r * c)
    
    -- for a needle that goes to center
    -- x1 = cx
    -- y1 = 10+cy
    
    -- for a needle that does not reach center
    x1 = 1+round(cx - 0.3 * r * s)
    y1 = 10 + round(cy - 0.3 * r * c)
    
    x2 = 1+round(cx - 0.9 * r * s)
    y2 = 10 + round(cy - 0.9 * r * c)
    
    WindowLine(win, x1, y1, x2, y2, handColor, 256, 2)
end --drawHand

function winTitle()
  local title = 'Tick Timer'
  res = WindowText(win, 'fTitle', title, (WindowInfo(win, 3) / 2 - WindowTextWidth(win, 'fTitle', title, false) / 2) + 1, 0.25 * WindowInfo(win, 4), 0, 0, titleColor, false)
end

function drawMenuHandle()
  WindowPolygon(win, "4,4,18,4,11,14" , menuColor, 6, 1, menuColor, 8 , true, false)
end

function testHand()
    local t=0
    while t<30 do
        drawHand(t)
        t = t + 1
    end
end

function showHelp()
end --showHelp
-------------------------------------------------------------------------------
-- BEGIN miniwindow event handler class
-------------------------------------------------------------------------------
function handlers.new(wName)
  local self = {}
  self.win = wName

  function self.mousedown(flags, hotspot_id)
    startx, starty = WindowInfo (self.win, 14), WindowInfo (self.win, 15)
    WindowSetZOrder(self.win, 1200)
    -- print ("we moused down on hotspot " .. hotspot_id)
  end -- mousedown

  function self.cancelmousedown(flags, hotspot_id)
    -- print ("we cancelled moused down for hotspot " .. hotspot_id)
  end -- cancelmousedown

  function self.mouseup(flags, hotspot_id)
    if hasbit(flags, miniwin.hotspot_got_rh_mouse) then
      myMenu.showMenu()
    end
    -- print ("we moused up on hotspot " .. hotspot_id)
  end -- mouseup

  function self.dragmove(flags, hotspot_id)
    if hasbit(flags, miniwin.hotspot_got_rh_mouse) then
      -- don't drag on right-click
      return
    end
    local posx, posy, flags = WindowInfo (self.win, 17),
                       WindowInfo (self.win, 18),
                       WindowInfo(self.win, 8)
  
    -- print ("moved to position", posx, posy)
    -- move the window to the new location
    WindowPosition(self.win, posx - startx, posy - starty, 0, setbit(flags, 2));
    
    -- change the mouse cursor shape appropriately
    if posx < 0 or posx > GetInfo (281) or
       posy < 0 or posy > GetInfo (280) then
      check (SetCursor ( 11))   -- X cursor
    else
      check (SetCursor ( 1))   -- hand cursor
    end -- if
    
  end -- dragmove
  
  function self.dragrelease(flags, hotspot_id)
    -- print ("mouse drag release for " .. hotspot_id)
    -- print ("released at position", WindowInfo (win, 17), WindowInfo (win, 18))
    -- print ("moved to position", posx, posy)
    -- the window was just moved, so this seems like a good time to save state
    OnPluginSaveState()
  end -- dragrelease
  
  return self
end --handlers.new
-------------------------------------------------------------------------------
-- END miniwindow event handler class
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- general utility functions
-------------------------------------------------------------------------------

function bit(p)
  return 2 ^ (p - 1)  -- 1-based indexing
end

-- Typical call:  if hasbit(x, bit(3)) then ...
function hasbit(x, p)
  return x % (p + p) >= p       
end

function setbit(x, p)
  return hasbit(x, p) and x or x + p
end

function clearbit(x, p)
  return hasbit(x, p) and x - p or x
end

function flipbit(x, p)
  return hasbit(x,p) and x - p or x + p
end

]]>
</script>
</muclient>
